<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Super ChartJS</title>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js"></script>

</head>

<body>
  <div id="chart-wrapper" class="chart-wrapper">
      <div id="analytics-1" class="analytics-wrapper"></div>
      <div id="analytics-1" class="analytics-wrapper"></div>

  </div>
  <div id="chart-wrapper" class="chart-wrapper">
    <div id="analytics-2" class="analytics-wrapper"></div>

  </div>
</body>

<script type="module">
  import { Plotter } from '../package/src/js/Plotter.js';
  // import { Plotter } from '../node_modules/superchartjs/dist/graph.es.js';
  // import { Plotter } from 'superchartjs';

  // First, declare all async functions
  async function predictFutureValues(values, periodsToPredict = 3) {
    // Prepare data for training
    const sequenceLength = 3;
    const xs = [];
    const ys = [];
    
    for (let i = 0; i < values.length - sequenceLength; i++) {
      xs.push(values.slice(i, i + sequenceLength));
      ys.push(values[i + sequenceLength]);
    }

    // Convert to tensors
    const xsTensor = tf.tensor2d(xs);
    const ysTensor = tf.tensor1d(ys);

    // Create and compile model
    const model = tf.sequential({
      layers: [
        tf.layers.dense({ units: 8, inputShape: [sequenceLength], activation: 'relu' }),
        tf.layers.dense({ units: 1 })
      ]
    });

    model.compile({
      optimizer: tf.train.adam(0.01),
      loss: 'meanSquaredError'
    });

    // Train the model
    await model.fit(xsTensor, ysTensor, {
      epochs: 100,
      verbose: 0
    });

    // Make predictions
    let lastSequence = values.slice(-sequenceLength);
    const predictions = [];

    for (let i = 0; i < periodsToPredict; i++) {
      const prediction = model.predict(tf.tensor2d([lastSequence]));
      const predictedValue = await prediction.data();
      predictions.push(Number(predictedValue[0].toFixed(2)));
      lastSequence = [...lastSequence.slice(1), predictedValue[0]];
    }

    // Cleanup
    model.dispose();
    xsTensor.dispose();
    ysTensor.dispose();

    return predictions;
  }

  async function analyzeChartData(chartData) {
    const analytics = [];
    
    for (const series of chartData.legends) {
      const values = series.data;
      const dates = chartData.xAxisValues;
      
      // Basic statistics
      const mean = d3.mean(values);
      const median = d3.median(values);
      const max = d3.max(values);
      const min = d3.min(values);
      const stdDev = d3.deviation(values);
      const q1 = d3.quantile(values.sort(d3.ascending), 0.25);
      const q3 = d3.quantile(values.sort(d3.ascending), 0.75);
      const iqr = q3 - q1;
      
      // Trend analysis
      const trend = values[values.length - 1] - values[0];
      const growthRate = ((values[values.length - 1] - values[0]) / values[0] * 100).toFixed(2);
      
      // Moving average (last 3 points)
      const movingAvg = values.map((_, i, arr) => {
        if (i < 2) return null;
        return d3.mean(arr.slice(i-2, i+1));
      }).filter(v => v !== null);
      
      // Volatility (using standard deviation of percentage changes)
      const percentageChanges = values.slice(1).map((v, i) => 
        ((v - values[i]) / values[i]) * 100
      );
      const volatility = d3.deviation(percentageChanges);
      
      // Find peaks and troughs
      const peaks = values.map((val, i) => ({
        value: val,
        date: dates[i],
        isPeak: i > 0 && i < values.length - 1 && 
                val > values[i - 1] && val > values[i + 1]
      })).filter(p => p.isPeak);
      
      const troughs = values.map((val, i) => ({
        value: val,
        date: dates[i],
        isTrough: i > 0 && i < values.length - 1 && 
                 val < values[i - 1] && val < values[i + 1]
      })).filter(t => t.isTrough);
      
      // Seasonality check (if enough data points)
      let seasonalityScore = "Insufficient data";
      if (values.length >= 12) {
        const correlations = [];
        for (let i = 0; i < values.length - 6; i++) {
          const slice1 = values.slice(i, i + 6);
          const slice2 = values.slice(i + 6, i + 12);
          if (slice2.length === 6) {
            correlations.push(d3.correlation(slice1, slice2));
          }
        }
        const avgCorrelation = d3.mean(correlations);
        seasonalityScore = avgCorrelation > 0.7 ? "Strong" : 
                          avgCorrelation > 0.4 ? "Moderate" : "Weak";
      }

          // TensorFlow.js Analysis
          const predictions = await predictFutureValues(values);
      const lastDate = new Date(dates[dates.length - 1]);
      const futureDates = Array.from({length: 3}, (_, i) => {
        const date = new Date(lastDate);
        date.setMonth(date.getMonth() + i + 1);
        return date.toISOString().slice(0, 10);
      });

        // Pattern Recognition
        const patterns = recognizePatterns(values);


      analytics.push(`
        <h4>${series.label} Comprehensive Analysis:</h4>
        <div class="analysis-section">
          <h5>Basic Statistics</h5>
          <ul>
            <li>Mean: ${mean.toFixed(2)}</li>
            <li>Median: ${median.toFixed(2)}</li>
            <li>Standard Deviation: ${stdDev.toFixed(2)}</li>
            <li>Highest Value: ${max} (${dates[values.indexOf(max)]})</li>
            <li>Lowest Value: ${min} (${dates[values.indexOf(min)]})</li>
            <li>Q1 (25th percentile): ${q1.toFixed(2)}</li>
            <li>Q3 (75th percentile): ${q3.toFixed(2)}</li>
            <li>Interquartile Range: ${iqr.toFixed(2)}</li>
          </ul>
        </div>

        <div class="analysis-section">
          <h5>Trend Analysis</h5>
          <ul>
            <li>Overall Trend: ${trend > 0 ? 'Upward' : 'Downward'}</li>
            <li>Growth Rate: ${growthRate}%</li>
            <li>Latest Moving Average (3-point): ${movingAvg[movingAvg.length-1].toFixed(2)}</li>
            <li>Volatility: ${volatility ? volatility.toFixed(2) : 'N/A'}%</li>
            <li>Seasonality: ${seasonalityScore}</li>
          </ul>
        </div>

        <div class="analysis-section">
          <h5>Key Points</h5>
          <ul>
            ${peaks.map(p => `
              <li>Peak: ${p.value} on ${p.date}</li>
            `).join('')}
            ${troughs.map(t => `
              <li>Trough: ${t.value} on ${t.date}</li>
            `).join('')}
          </ul>
        </div>

        <div class="analysis-section">
          <h5>Summary Insights</h5>
          <ul>
            <li>${generateInsight(mean, stdDev, growthRate, volatility)}</li>
            <li>${generateTrendInsight(values, dates)}</li>
          </ul>
        </div>


        <!-- New TensorFlow.js Analysis Section -->
        <div class="analysis-section">
          <h5>Predictive Analysis</h5>
          <ul>
            ${predictions.map((pred, i) => `
              <li>Predicted value for ${futureDates[i]}: ${pred}</li>
            `).join('')}
          </ul>
        </div>

        <div class="analysis-section">
          <h5>Pattern Recognition</h5>
          <ul>
            ${patterns.map(pattern => `
              <li>${pattern}</li>
            `).join('')}
          </ul>
        </div>
      `);
    }

    return analytics.join('');
  }

  // Helper functions (non-async)
  function generateInsight(mean, stdDev, growthRate, volatility) {
    let insight = `The data shows an average of ${mean.toFixed(2)} with `;
    insight += stdDev < mean * 0.1 ? "low variability" : 
               stdDev < mean * 0.25 ? "moderate variability" : "high variability";
    insight += `. Growth rate is ${growthRate}% with ${
      volatility < 10 ? "low" : 
      volatility < 25 ? "moderate" : "high"
    } volatility.`;
    return insight;
  }

  function generateTrendInsight(values, dates) {
    const recentTrend = values.slice(-3);
    const isIncreasing = recentTrend[2] > recentTrend[0];
    const magnitude = Math.abs(((recentTrend[2] - recentTrend[0]) / recentTrend[0]) * 100);
    
    return `Recent trend (last 3 periods) shows a ${
      isIncreasing ? "positive" : "negative"
    } movement of ${magnitude.toFixed(1)}%`;
  }

  function recognizePatterns(values) {
    const patterns = [];
    
    // Detect trends
    const recentValues = values.slice(-5);
    const consistentIncrease = recentValues.every((v, i) => i === 0 || v > recentValues[i - 1]);
    const consistentDecrease = recentValues.every((v, i) => i === 0 || v < recentValues[i - 1]);
    
    // Detect cycles
    const differences = values.slice(1).map((v, i) => v - values[i]);
    const signChanges = differences.slice(1).map((d, i) => 
      Math.sign(d) !== Math.sign(differences[i])
    ).filter(Boolean).length;
    
    // Add detected patterns
    if (consistentIncrease) {
      patterns.push("Consistent upward trend detected in recent data");
    } else if (consistentDecrease) {
      patterns.push("Consistent downward trend detected in recent data");
    }
    
    if (signChanges > values.length / 3) {
      patterns.push("Cyclical pattern detected");
    }
    
    // Detect outliers using z-score
    const mean = d3.mean(values);
    const stdDev = d3.deviation(values);
    const outliers = values.map((v, i) => ({
      value: v,
      index: i,
      zScore: Math.abs((v - mean) / stdDev)
    })).filter(item => item.zScore > 2);
    
    if (outliers.length > 0) {
      patterns.push(`${outliers.length} significant outlier(s) detected`);
    }

    return patterns;
  }

  // Event listener
  document.addEventListener('DOMContentLoaded', async () => {
    const chartData = {
      chartTitle: "Monthly Sales Revenue",
      xAxisValues: [
        "2024-01-01",
        "2024-02-01",
        "2024-03-01",
        "2024-04-01",
        "2024-05-01",
        "2024-06-01",
        "2024-07-01",
        "2024-08-01",
        "2024-09-01",
        "2024-10-01",
        "2024-11-01",
        "2024-12-01"

      ],
      axisLabels: {
        xAxisLabel: "Month",
        yAxisLabel: "Revenue (USD)"
      },
      legends: [
        {
          label: "Product A Sales",
          data: [500, 700, 800, 1200, 1500, 1400, 600, 550, 900, 1000, 1100],
          type: "area",
        },
      ],
      toggleChartTypeSwitch: true,
      legendSorting: true,
      drawToolBox: true
    };

    const chartData2 = {
      chartTitle: "Website Traffic Overview",
      xAxisValues: [
        "2024-01-01",
        "2024-02-01",
        "2024-03-01",
        "2024-04-01",
        "2024-05-01",
        "2024-06-01"
      ],
      axisLabels: {
        xAxisLabel: "Month",
        yAxisLabel: "Number of Visitors"
      },
      legends: [
        {
          label: "Organic Traffic",
          data: [2000, 3000, 3500, 4000, 4500, 5000],
          type: "area",
        },
        {
          label: "Paid Traffic",
          data: [800, 1200, 1500, 1800, 2000, 2200],
          type: "line",
          fillColor: false,
          aboveColor: false
        }
      ],
      legendSorting: true,
      toggleChartTypeSwitch: true,
      drawToolBox: true
    };

    try {
      // First plot the charts
      const graph = new Plotter();
      graph.plotChart(chartData);
      graph.plotChart(chartData2);

      // Then get the analytics
      const analytics1 = await analyzeChartData(chartData);
      const analytics2 = await analyzeChartData(chartData2);

      // Update the DOM with results
      document.getElementById('analytics-1').innerHTML = `
        <h3>Data Analysis for ${chartData.chartTitle}</h3>
        ${analytics1}
      `;

      document.getElementById('analytics-2').innerHTML = `
        <h3>Data Analysis for ${chartData2.chartTitle}</h3>
        ${analytics2}
      `;
    } catch (error) {
      console.error('Error analyzing chart data:', error);
      document.getElementById('analytics-1').innerHTML = 'Error analyzing chart data';
      document.getElementById('analytics-2').innerHTML = 'Error analyzing chart data';
    }
  });
</script>


<style>
  .analytics-wrapper {
    margin: 20px;
    padding: 15px;
    border: 1px solid #ddd;
    border-radius: 5px;
    background-color: #f9f9f9;
  }

  .analysis-section {
    margin: 15px 0;
    padding: 10px;
    background-color: white;
    border-radius: 5px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  }

  .analysis-section h5 {
    color: #2c3e50;
    margin: 0 0 10px 0;
    padding-bottom: 5px;
    border-bottom: 2px solid #eee;
  }

  .analytics-wrapper ul {
    list-style-type: none;
    padding-left: 0;
    margin: 0;
  }

  .analytics-wrapper li {
    margin: 8px 0;
    padding: 5px;
    background-color: #f8f9fa;
    border-radius: 3px;
    font-size: 0.9em;
  }

  .analytics-wrapper h4 {
    color: #333;
    margin: 15px 0 10px 0;
    padding: 10px;
    background-color: #e9ecef;
    border-radius: 5px;
  }
</style>

</html>
